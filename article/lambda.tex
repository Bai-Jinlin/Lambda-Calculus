\documentclass[a4paper,adobefonts]{ctexart}
\usepackage[a4paper,margin=2.5cm]{geometry}
\usepackage[colorlinks=true,allcolors=black]{hyperref}
\usepackage[svgnames]{xcolor}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{fancyvrb,fancybox,calc}
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{unicode-math}
\usepackage{url}

\setmainfont{Minion Pro}
\setmonofont{Source Code Pro}
\pagestyle{plain}
\punctstyle{kaiming}
\setmathfont{Asana Math}
\graphicspath{{pic/}}

\newcommand{\downloadurl}{\url{http://www.twitter.com}}

\newenvironment{verbcode}{\VerbatimEnvironment%
  \noindent
  \begin{Sbox}
  \begin{minipage}{.96\textwidth}
  \begin{Verbatim}
}{%
  \end{Verbatim}
  \end{minipage}
  \end{Sbox}
  \begin{center}\colorbox{LightGray}{\TheSbox}\end{center}
}

\begin{document}
\title{{\bfseries 让我们谈谈 $\lambda$ 演算}}
\author{王盛颐\\\href{mailto:txyyss@gmail.com}{txyyss@gmail.com}}
\date{}
\maketitle

\section*{缘起}

``写篇介绍 $\lambda$ 演算的文章''这一条目在我的待办事项列表里已经躺了
很久了。我本科看``计算机程序的构造和解释''（SICP）一书时，接触到了
$\lambda$ 表达式这个概念。当时我觉得它就是一种表示匿名函数的记法。有了
这个记法，把函数作为值来传递、返回以及组合都方便了很多，别的也没多想。

SICP 里面用的 Scheme 语言让我见识到了世界上还有一类叫 ``函数式'' 的程
序设计语言。搜索相关资料，都说 $\lambda$ 演算是函数式语言的基础。好奇
心害死猫啊，我自然是要看看 $\lambda$ 演算是怎么一回事的。一番了解之后，
我觉得如此形式简单而内涵丰富的东西，就是美的体现啊。尤其当我看到
Church 数的时候，那种``啊哈''的惊艳感真是永生难忘。

后来我学了越来越多的关于计算机，特别是程序设计语言的理论，发现
$\lambda$ 演算从可计算性理论到形式语义到类型理论，无处不在，自己目前所
知不过皮毛罢了。刚好我最近因为学习 Haskell 语言，实现了一个简单的无类
型纯 $\lambda$ 演算解释器。于是我决定写篇初步介绍无类型纯 $\lambda$ 演
算的文章，有个解释器的好处是能一边介绍一边通过解释器演示规约求值的过程，
让相对抽象的 $\lambda$ 演算更加直观和易于理解。

\section{历览前贤}

一切要从上个世纪初，也就是 1900 年左右开始说起了。那时候数学界的气象是
这样的：希尔伯特刚刚提出他的 23 个问题，其中第 2 个问题问的是公理系统
的相容性；1901 年提出的，动摇了集合论基础的罗素悖论还是个很流行的话题；
至于哥德尔不完备性定理呢，大家都还不知道。所以在这之后的几十年很多数学
家和逻辑学家都在致力于给整个数学建立一个一致的公理基础。比如罗素和怀特
海德写了``数学原理''（Principia Mathematica）；比如约翰·冯·诺伊曼
\footnote{对，你没有看错，他就是那个定下了计算机基本结构``冯·诺伊曼结
  构''的那个冯·诺伊曼。}写了关于公理化集合论的博士论文；再比如阿隆佐·
邱奇（Alonzo Church）提出了 $\lambda$ 演算。

邱奇是个美国逻辑学家，生于 1903 年。他在 1928 年开始构造的一个形式系统
中包含了纯 $\lambda$ 演算。他发明这一形式系统的初衷是为了给逻辑学提供一
个基础，能代替罗素的类型理论和恩斯特·策梅洛（Ernst Zermelo）
\footnote{他就是 ZFC 公理化集合论的那个``Z''。}的集合理论。这个系统
1932 年发表后不久就被发现有矛盾，于是一年后邱奇修正了一番重新发表。当
时的人对不完备性定理威力有多大还缺乏清醒广泛的认识。所以他还希望那时发
现不久的哥德尔关于``数学原理''一书的不完备性定理不会扩展到他的系统上。

愿望是良好的，结果是残酷的。到 1935 年，邱奇的两个学生，Stephen Kleene
和 Barkley Rosser 发现邱奇的逻辑系统是不一致的。不过柳暗花明又一村，他
们发现系统包含的纯 $\lambda$ 演算则具有一系列良好的性质，再后来更是证
明用 $\lambda$ 演算可以等价的定义出可计算函数，邱奇觉得能有效计算的函
数等价于 $\lambda$ 可定义性，这就是著名的``邱奇--图灵论题''的一部分了。
更一进步的，邱奇用 $\lambda$ 演算证明了一阶逻辑不存在递归判定过程，这
是对希尔伯特提出的判定性问题（Entscheidungsproblem）的第一个否定性答案，
这比用图灵证明停机问题不可判定还要早几个月。

不过二十世纪三十年代在 $\lambda$ 演算方面的成果差不多也就这些了，再接
下来的 20 年都没有太多研究和进展。直到六十年代，那时有了计算机，有了程
序设计语言，有了计算机科学家。在 1965 年，英国计算机科学家 Peter
Landin 发现可以通过把复杂的程序语言转化成简单的$\lambda$ 演算，来理解
程序语言的行为。这个洞见可以让我们把 $\lambda$演算本身看成一种程序设计
语言。而众所周知的 John McCarthy 的 Lisp 语言，更是让 $\lambda$ 演算广
为传播。现在不论是各种实际的程序设计语言还是理论上的研究工作，
$\lambda$ 演算都是一个绕不过去的基本工具了。

$\lambda$ 演算之所以这么重要，用 Benjamin C. Pierce 的话说在于它具有某
种``二象性''：它既可以被看作一种简单的程序设计语言，用于描述计算过程，
也可以被看作一个数学对象，用于推导证明一些命题。在这篇介绍文章里，我也
打算从两个方面来讲，先讲它作为数学理论这方面的内容。

\section{数学理论}
让我们先从数学开始说起。函数是数学中一个非常基本的概念，我们很容易就能
写出一个计算平方和的函数如下：
\begin{equation}
f(x,y) = x\times x + y\times y.
\end{equation}
上面这个平方和函数有个名字叫 $f$，有名字的好处是能方便的表示后续的计算，比如：
$$
f(3,4) = 3\times 3 + 4 \times 4 = 25.
$$但再想想，名字对一个函数来讲是必须的么？当然不是，下面这个映射也表示
了平方和函数：
\begin{equation}\label{eqn:mapfun}
(x,y)\mapsto x\times x + y\times y
\end{equation}
把 (\ref{eqn:mapfun}) 整体当成函数的名字，同样可以表示计算平方和过程：
$$
((x,y)\mapsto x\times x + y\times y)(3,4)=3\times 3 + 4\times 4 = 25.
$$

我们把 (\ref{eqn:mapfun}) 称为匿名函数，它有两个参数。那么再问，单参数
函数和多参数函数的区分有必要吗？可以换个角度来看，我们把
(\ref{eqn:mapfun}) 改写成下面这个样子：
\begin{equation}\label{eqn:highfun}
x\mapsto(y\mapsto x\times x + y \times y).
\end{equation}
这个映射是什么意思呢？$x$ 被映射成了 $y\mapsto x\times x + y \times y$，
后者是一个以 $y$ 为参数的函数。换句话说，(\ref{eqn:highfun}) 表示的是
把一个数映射成函数的函数，这就是所谓的``高阶函数''（High-Order
  Function）了。注意，(3) 现在是个单参数的函数，我们可以把它先应用于参
数 3，得到一个新的函数：
$$
(x\mapsto(y\mapsto x\times x + y \times y))(3)
=y\mapsto 3\times 3 + y \times y = y\mapsto 9 + y \times y.
$$
再把这个函数应用于参数 4：
$$
(y\mapsto 9 + y \times y)(4)=9+4\times 4=25.
$$这样就清楚了，(\ref{eqn:highfun}) 同样可以进行平方和的计算。用类
似的方法，可以把任意多参数函数都转换成单参数的高阶函数，这个转换又叫做
柯里化（Currying），这是以数学家 Haskell Brooks Curry 命名的。

匿名函数和柯里化，是 $\lambda$ 演算为简化函数概念而采取的方法，上面这
段说明可以看作是 $\lambda$ 演算的非正式介绍。事实上，大多数程序语言里
的所谓 Lambda 表达式，也就是这两个概念组合在一起罢了。下面正式介绍严格
的，形式化的 $\lambda$ 演算。

\subsection{形式化定义}\label{subsec:formal}
\newpage
\appendix
%% \section{\texorpdfstring{$\lambda$ 演算解释器简要使用说明}{$Lambda 演算解释器简要使用说明}}
\section{解释器简要使用说明}

在学习了解 $\lambda$ 演算的过程中，为了加深自己对 $\lambda$ 演算的感性
认识，我实现了一个简单的解释器。这个解释器只实现了两个简单的功能：对无
类型纯 $\lambda$ 演算进行 $\beta$ 规约，允许命名绑定组合子。有了这两个
简单的功能，就可以把 $\lambda$ 演算当作一种程序设计语言，真实不虚的
``运行''这篇文章里介绍的各种 $\lambda$ 项，看到归约后的结果。用户还可
以对解释器做一些设置，决定输出形式，是否逐步给出规约过程等等。

解释器可以从这个地方下载：\downloadurl。这个解释器中用字符 \verb|\|
代表 $\lambda$，其余语法和 \ref{subsec:formal} 中定义的一样。下面介绍
一下用户可以设定的参数。

默认设置下，解释器会自动对用户输入的 $\lambda$ 项不断进行 $\beta$ 规约，
直到得到一个正则形式（如果存在的话）。可用命令 \verb|:set +hold| 让解
释器进入``原样输出''模式，命令 \verb|:set -hold| 则恢复立即执行的模式。

\begin{verbcode}
Lambda> (\x.\y.y x) a b
b a
Lambda> :set +hold
Lambda> (\x.\y.y x) a b
(\x.\y.y x) a b
\end{verbcode}

解释器默认的输出样式省略了不必要的括号，可以用命令
\verb|:set +fullform| 和 \verb|:set -fullform| 控制是否输出全部带括号
的结果。

\begin{verbcode}
Lambda> (a b) c d e f g
a b c d e f g
Lambda> :set +fullform
Lambda> a b c d e f g
(((((a b) c) d) e) f) g
Lambda> \x.\y.y x a b
\x.(\y.(((y x) a) b))
\end{verbcode}

解释器默认情况下，只输出最终的规约结果，可以用命令 \verb|:set +trace|
和 \verb|:set -trace| 控制是否输出中间结果。

\begin{verbcode}
Lambda> (\x.\y.y x) a b
b a
Lambda> :set +trace
Lambda> (\x.\y.y x) a b
==> (\x.\y.y x) a b
==> (\y.y a) b
==> b a
\end{verbcode}

由于一个 $\lambda$ 项是否一定可以被 $\beta$ 规约规约到正则形式是不可判
定的，所以为了折衷解决这个问题，解释器设置了一个阈值，当规约步数超过
``$\lambda$ 项长度$\times$阈值'' 时，解释器就输出说疑似不可规约。这个
阈值可以用 \verb|:set steps 非负整数| 来修改，默认是 100。用户若是觉得
阈值及前述三个控制选项经多次修改之后太乱了，可以用命令
\verb|:reset settings| 来恢复默认设置。

\begin{verbcode}
Lambda> (\x.\y.y y x) a b
b b a
Lambda> :set steps 0
Lambda> (\x.\y.y y x) a b
(\x.\y.y y x) a b seems can't be reduced!
Lambda> :reset settings
Lambda> (\x.\y.y y x) a b
b b a
\end{verbcode}

解释器支持用户绑定名称到组合子，注意，只能是组合子，也就是没有自由变量
的 $\lambda$ 项。组合子中可以出现已经绑定的名称，但不允许递归定义。已
经绑定的名称不能再次绑定。
\begin{verbcode}
Lambda> swap = \x.\y.y x
Lambda> swap a b
b a
Lambda> foo = swap \x.x
Lambda> foo \x.y
y
Lambda> id = id \x.x
id can't be recursively defined!
Lambda> foo = \x.x
foo has been defined already!
\end{verbcode}

解释器已经默认绑定了一些这篇文章里出现的组合子，全部列表可见
\ref{sec:bindCombinator}。用户在添加了自己的绑定后，可以用
\verb|:reset state| 来恢复默认的绑定，清空自定义的绑定。也可以用命令
\verb|:clear state| 来清空全部的绑定。
\begin{verbcode}
Lambda> plus
\m.m \n.\f.\x.f (n f x)
Lambda> plus four four
\f.\x.f (f (f (f (f (f (f (f x)))))))
Lambda> id = \x.x
Lambda> id a
a
Lambda> :reset state
Lambda> id a
id a
Lambda> :clear state
Lambda> plus four four
plus four four
Lambda> :reset state
Lambda> plus four four
\f.\x.f (f (f (f (f (f (f (f x)))))))
\end{verbcode}

以上就是用户在 $\lambda$ 演算解释器里可以做的全部设置了。要退出解释器，
输入 \verb|:q| 命令即可。

\section{解释器默认绑定的组合子和名称}\label{sec:bindCombinator}
其实就是依次运行如下命令后，解释器内部状态中绑定的组合子。
\begin{verbcode}
zero   = \f.\x.x
succ   = \n.\f.\x.f (n f x)
plus   = \m.\n.m succ n
mult   = \m.\n.\f.m (n f)
pow    = \b.\e.e b
pred   = \n.\f.\x.n (\g.\h.h (g f)) (\u.x) (\u.u)
sub    = \m.\n.n pred m
one    = succ zero
two    = succ one
three  = succ two
four   = succ three
true   = \x.\y.x
false  = \x.\y.y
and    = \p.\q.p q p
or     = \p.\q.p p q
not    = \p.\a.\b.p b a
if     = \p.\a.\b.p a b
iszero = \n.n (\x.false) true
leq    = \m.\n.iszero (sub m n)
eq     = \m.\n. and (leq m n) (leq n m)
Y      = \g.(\x.g (x x)) (\x.g (x x))
\end{verbcode}
\end{document}
