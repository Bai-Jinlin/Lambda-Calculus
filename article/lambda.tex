\documentclass[a4paper,adobefonts]{ctexart}
\usepackage{amsmath,amsthm,amssymb}
\usepackage[colorlinks=true,allcolors=black]{hyperref}
\usepackage{indentfirst}
\usepackage[a4paper,left=2.5cm,right=2.5cm,bottom=2.5cm,top=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{url}
\usepackage{fontspec}
\setmainfont{Palatino}
\setmonofont[Scale=MatchLowercase]{Monaco}
\pagestyle{plain}
\punctstyle{kaiming}
\usepackage{unicode-math}
\setmathfont{Asana Math}
\graphicspath{{pic/}}

\begin{document}
\title{{\bfseries 让我们谈谈 $\lambda$ 演算}}
\author{\href{mailto:txyyss@gmail.com}{王盛颐}}
\date{}
\maketitle

\section*{缘起}

``写篇介绍 $\lambda$ 演算的文章''这一条目在我的待办事项列表里已经躺了
很久了。我本科看``计算机程序的构造和解释''（SICP）一书时，接触到了
$\lambda$ 表达式这个概念。当时我觉得它就是一种表示匿名函数的记法。有了
这个记法，把函数作为值来传递、返回以及组合都方便了很多，别的也没多想。

SICP 里面用的 Scheme 语言让我见识到了世界上还有一类叫 ``函数式'' 的程
序设计语言。搜索相关资料，都说 $\lambda$ 演算是函数式语言的基础。好奇
心害死猫啊，我自然是要看看 $\lambda$ 演算是怎么一回事的。一番了解之后，
我觉得如此形式简单而内涵丰富的东西，就是美的体现啊。尤其当我看到
Church 数的时候，那种``啊哈''的惊艳感真是永生难忘。

后来我学了越来越多的关于计算机，特别是程序设计语言的理论，发现
$\lambda$ 演算从可计算性理论到形式语义到类型理论，无处不在，自己目前所
知不过皮毛罢了。刚好我最近因为学习 Haskell 语言，实现了一个简单的无类
型纯 $\lambda$ 演算解释器。于是我决定写篇初步介绍无类型纯 $\lambda$ 演
算的文章，有个解释器的好处是能一边介绍一边通过解释器演示规约求值的过程，
让相对抽象的 $\lambda$ 演算更加直观和易于理解。

\section{历览前贤}

一切要从上个世纪初，也就是 1900 年左右开始说起了。那时候数学界的气象是
这样的：希尔伯特刚刚提出他的 23 个问题，其中第 2 个问题问的是公理系统
的相容性；1901 年提出的，动摇了集合论基础的罗素悖论还是个很流行的话题；
至于哥德尔不完备性定理呢，大家都还不知道。所以在这之后的几十年很多数学
家和逻辑学家都在致力于给整个数学建立一个一致的公理基础。比如罗素和怀特
海德写了``数学原理''（Principia Mathematica）；比如约翰·冯·诺伊曼
\footnote{对，你没有看错，他就是那个定下了所有现代计算机基本结构``冯·
  诺伊曼结构''的那个冯·诺伊曼。}写了关于公理化集合论的博士论文；再比
如阿隆佐·邱奇（Alonzo Church）提出了 $\lambda$ 演算。

邱奇是个美国逻辑学家，生于 1903 年。他在 1928 年开始构造的一个形式系统
中包含了纯 $\lambda$ 演算。他发明这一形式系统的初衷是为了给逻辑学提供一
个基础，能代替罗素的类型理论和恩斯特·策梅洛（Ernst Zermelo）
\footnote{他就是 ZFC 公理化集合论的那个``Z''。}的集合理论。这个系统
1932 年发表后不久就被发现有矛盾，于是一年后邱奇修正了一番重新发表。当
时的人对不完备性定理威力有多大还缺乏清醒广泛的认识。所以他还希望那时发
现不久的哥德尔关于``数学原理''一书的不完备性定理不会扩展到他的系统上。

愿望是良好的，结果是残酷的。到 1935 年，邱奇的两个学生，Stephen Kleene
和 Barkley Rosser 发现邱奇的逻辑系统是不一致的。不过柳暗花明又一村，他
们发现系统包含的纯 $\lambda$ 演算则具有一系列良好的性质，再后来更是证
明用 $\lambda$ 演算可以等价的定义出可计算函数，邱奇觉得能有效计算的函
数等价于 $\lambda$ 可定义性，这就是著名的``邱奇--图灵论题''的一部分了。
更一进步的，邱奇用 $\lambda$ 演算证明了一阶逻辑不存在递归判定过程，这
是对希尔伯特提出的判定性问题（Entscheidungsproblem）的第一个否定性答案，
这比用图灵证明停机问题不可判定还要早几个月。

不过二十世纪三十年代在 $\lambda$ 演算方面的成果差不多也就这些了，再接
下来的 20 年都没有太多 $\lambda$ 演算方面的研究和进展。直到六十年代，
那时有了计算机，有了程序设计语言，有了计算机科学家。在 1965 年，英国计
算机科学家 Peter Landin 发现可以通过把复杂的程序语言转化成简单的
$\lambda$ 演算，来理解程序语言的行为。这个洞见可以让我们把 $\lambda$
演算本身看成一种程序设计语言。而众所周知的 John McCarthy 的 Lisp 语言，
更是让 $\lambda$ 演算广为传播。现在不论是各种实际的程序设计语言还是理
论上的研究工作，$\lambda$ 演算都是一个绕不过去的基本工具了。

$\lambda$ 演算之所以这么重要，用 Benjamin C. Pierce 的话说在于它具有某
种``二象性''：它既可以被看作一种简单的程序设计语言，用于描述计算过程，
也可以被看作一个数学对象，用于推导证明一些命题。在这篇介绍无类型纯
$\lambda$ 演算的文章里，我也打算从两个方面来讲，先讲它作为数学理论这方
面的内容。

\section{数学理论}
让我们先从数学开始说起。函数是数学中一个非常基本的概念，我们很容易就能
写出一个计算平方和的函数如下：
\begin{equation}
f(x,y) = x\times x + y\times y.  
\end{equation}
上面这个平方和函数有个名字叫 $f$，有名字的好处是能方便的表示后续的计算，比如：
$$
f(3,4) = 3\times 3 + 4 \times 4 = 25.
$$但再想想，名字对一个函数来讲是必须的么？当然不是，下面这个映射也表示
了平方和函数：
\begin{equation}\label{eqn:mapfun}
(x,y)\mapsto x\times x + y\times y
\end{equation}
把 (\ref{eqn:mapfun}) 看成匿名函数，同样可以把它应用于参数 3 和 4：
$$
((x,y)\mapsto x\times x + y\times y)(3,4)=3\times 3 + 4\times 4 = 25.
$$

更进一步的，单参数函数和多参数函数的区分有必要吗？我们可以换个角度来看，
把 (\ref{eqn:mapfun}) 改写成下面这个样子：
\begin{equation}\label{eqn:highfun}
x\mapsto(y\mapsto x\times x + y \times y).  
\end{equation}
这个映射是什么意思呢？$x$ 被映射成了 $y\mapsto x\times x + y \times y$，
后者是一个以 $y$ 为参数的函数。换句话说，(\ref{eqn:highfun}) 表示的是
把一个数映射成函数的函数，这就是所谓的``高阶函数''（High-Order
  Function）了。注意，(3) 现在是个单参数的函数，我们可以把它先应用于参
数 3，得到一个新的函数：
$$
(x\mapsto(y\mapsto x\times x + y \times y))(3)
=y\mapsto 3\times 3 + y \times y = y\mapsto 9 + y \times y.
$$
再把这个函数应用于参数 4：
$$
(y\mapsto 9 + y \times y)(4)=9+4\times 4=25.
$$这样就清楚了，(\ref{eqn:highfun}) 同样可以进行平方和的计算。用类
似的方法，可以把任意多参数函数都转换成单参数的高阶函数，这个转换又叫做
柯里化（Currying），这是以数学家 Haskell Brooks Curry 命名的。

匿名函数和柯里化，是 $\lambda$ 演算为简化函数概念而采取的方法，上面这
段说明可以看作是 $\lambda$ 演算的非正式介绍。事实上，大多数程序语言里
的所谓 Lambda 表达式，也就是这两个概念组合在一起罢了。下面正式介绍严格
的，形式化的 $\lambda$ 演算。

\subsection{形式化定义}

\end{document}
